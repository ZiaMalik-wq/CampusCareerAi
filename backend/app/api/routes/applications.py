from datetime import datetime
from fastapi import APIRouter, Depends, HTTPException, status
from sqlmodel import Session, select
from app.db.session import get_session
from app.models.auth import User, UserRole
from app.models.job import Job
from app.models.application import Application, ApplicationStatus
from app.schemas import ApplicationPublic, ApplicantPublic
from app.api.deps import get_current_user
from app.models.auth import Company, Student
from app.core.supabase import supabase

router = APIRouter()

@router.post("/{job_id}", response_model=ApplicationPublic)
def apply_to_job(
    job_id: int,
    session: Session = Depends(get_session),
    current_user: User = Depends(get_current_user)
):
    """
    Student applies to a Job.
    Uses SQL Transaction with Row Locking to prevent race conditions.
    """
    # 1. Security Check
    if current_user.role != UserRole.STUDENT:
        raise HTTPException(status_code=403, detail="Only students can apply to jobs")
    
    if not current_user.student_profile:
        raise HTTPException(status_code=404, detail="Student profile incomplete")

    # 2. START TRANSACTION
    statement = select(Job).where(Job.id == job_id).with_for_update()
    job = session.exec(statement).one_or_none()

    if not job:
        raise HTTPException(status_code=404, detail="Job not found")
    
    if not job.is_active:
        raise HTTPException(status_code=400, detail="This job is closed")

    if job.deadline:
        if datetime.utcnow() > job.deadline:
            raise HTTPException(status_code=400, detail="The application deadline has passed")

    # 3. Check for Duplicate Application
    existing_app = session.exec(
        select(Application)
        .where(Application.job_id == job_id)
        .where(Application.student_id == current_user.student_profile.id)
    ).first()

    if existing_app:
        raise HTTPException(status_code=400, detail="You have already applied for this job")

    # 4. Create Application
    new_application = Application(
        job_id=job.id,
        student_id=current_user.student_profile.id,
        status=ApplicationStatus.APPLIED
    )
    
    session.add(new_application)
    session.commit()
    session.refresh(new_application)

    # 5. Format Response
    return ApplicationPublic(
        id=new_application.id,
        job_id=new_application.job_id,
        student_id=new_application.student_id,
        status=new_application.status,
        applied_at=new_application.applied_at,
        job_title=job.title,
        company_name=job.company.company_name if job.company else "Unknown"
    )


@router.get("/me", response_model=list[ApplicationPublic])
def get_my_applications(
    session: Session = Depends(get_session),
    current_user: User = Depends(get_current_user)
):
    """
    Get all applications for the logged-in student.
    Includes Job Title and Company Name for display.
    """
    if current_user.role != UserRole.STUDENT:
        raise HTTPException(status_code=403, detail="Only students have applications")
    
    if not current_user.student_profile:
        return []

    # Fetch applications linked to this student
    # We join Job and Company to get the names in one query
    statement = (
        select(Application, Job, Company)
        .join(Job, Application.job_id == Job.id)
        .join(Company, Job.company_id == Company.id)
        .where(Application.student_id == current_user.student_profile.id)
        .order_by(Application.applied_at.desc())
    )
    
    results = session.exec(statement).all()
    
    # Format output
    applications_list = []
    for application, job, company in results:
        app_data = application.model_dump()
        
        # Manually attach details from the joined tables
        app_data["job_title"] = job.title
        app_data["job_location"] = job.location
        app_data["company_name"] = company.company_name
        
        applications_list.append(ApplicationPublic(**app_data))
        
    return applications_list


@router.get("/job/{job_id}", response_model=list[ApplicantPublic])
def get_job_applicants(
    job_id: int,
    session: Session = Depends(get_session),
    current_user: User = Depends(get_current_user)
):
    """
    Company: View all students who applied to a specific job.
    Includes logic to generate secure Resume Links.
    """
    # 1. Security: Only Companies allowed
    if current_user.role != UserRole.COMPANY or not current_user.company_profile:
        raise HTTPException(status_code=403, detail="Only companies can view applicants")

    # 2. Security: Verify Job Ownership
    job = session.get(Job, job_id)
    if not job:
        raise HTTPException(status_code=404, detail="Job not found")
    
    if job.company_id != current_user.company_profile.id:
        raise HTTPException(status_code=403, detail="You do not own this job posting")

    # 3. Fetch Applications + Student Info + User Email
    statement = (
        select(Application, Student, User)
        .join(Student, Application.student_id == Student.id)
        .join(User, Student.user_id == User.id)
        .where(Application.job_id == job_id)
        .order_by(Application.applied_at.desc())
    )
    
    results = session.exec(statement).all()
    
    # 4. Format Data & Sign Resume URLs
    applicants_list = []
    for application, student, user in results:
        
        # Generate Signed URL for Resume (Valid for 1 hour)
        secure_resume_link = None
        if student.resume_url:
            try:
                # Assuming student.resume_url stores the path "5/cv.pdf"
                path = student.resume_url
                res = supabase.storage.from_("resumes").create_signed_url(path, 3600)
                secure_resume_link = res.get("signedURL") if isinstance(res, dict) else res
            except Exception:
                secure_resume_link = None

        applicant_data = ApplicantPublic(
            application_id=application.id,
            student_id=student.id,
            full_name=student.full_name,
            email=user.email,
            university=student.university,
            cgpa=student.cgpa,
            skills=student.skills,
            resume_url=secure_resume_link,
            status=application.status,
            applied_at=application.applied_at
        )
        applicants_list.append(applicant_data)
        
    return applicants_list